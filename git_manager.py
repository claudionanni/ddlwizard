"""
Git repository management for DDL Wizard.
"""

import os
import git
import logging
from typing import Dict, List, Optional
from pathlib import Path

logger = logging.getLogger(__name__)


class GitManager:
    """Manages git repository for DDL objects."""
    
    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path)
        self.repo = None
    
    def init_repository(self) -> bool:
        """Initialize git repository if it doesn't exist."""
        try:
            if self.repo_path.exists() and (self.repo_path / '.git').exists():
                self.repo = git.Repo(self.repo_path)
                logger.info(f"Using existing git repository at {self.repo_path}")
            else:
                self.repo_path.mkdir(parents=True, exist_ok=True)
                self.repo = git.Repo.init(self.repo_path)
                logger.info(f"Initialized new git repository at {self.repo_path}")
                
                # Create initial .gitignore
                gitignore_path = self.repo_path / '.gitignore'
                gitignore_path.write_text("*.log\n*.tmp\n__pycache__/\n")
                
            return True
        except Exception as e:
            logger.error(f"Failed to initialize git repository: {e}")
            return False
    
    def create_directory_structure(self):
        """Create directory structure for different object types."""
        directories = ['tables', 'functions', 'procedures', 'triggers', 'events']
        
        for directory in directories:
            dir_path = self.repo_path / directory
            dir_path.mkdir(exist_ok=True)
            logger.debug(f"Created directory: {dir_path}")
    
    def save_object_ddl(self, object_type: str, object_name: str, ddl: str) -> bool:
        """Save DDL for a database object to a file."""
        try:
            object_dir = self.repo_path / object_type
            object_dir.mkdir(exist_ok=True)
            
            file_path = object_dir / f"{object_name}.sql"
            
            # Add header comment with metadata
            from datetime import datetime
            content = f"""-- {object_type.upper()}: {object_name}
-- Generated by DDL Wizard
-- Timestamp: {datetime.now().isoformat()}

{ddl}
"""
            
            file_path.write_text(content, encoding='utf-8')
            logger.debug(f"Saved {object_type} DDL: {file_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save DDL for {object_type}/{object_name}: {e}")
            return False
    
    def save_all_objects(self, objects_data: Dict[str, List[Dict]], get_ddl_func) -> bool:
        """Save DDL for all database objects."""
        try:
            for object_type, objects in objects_data.items():
                logger.info(f"Processing {len(objects)} {object_type}...")
                
                for obj in objects:
                    object_name = obj['name']
                    ddl = get_ddl_func(object_type, object_name)
                    
                    if ddl:
                        self.save_object_ddl(object_type, object_name, ddl)
                    else:
                        logger.warning(f"No DDL found for {object_type}/{object_name}")
            
            return True
        except Exception as e:
            logger.error(f"Failed to save objects: {e}")
            return False
    
    def commit_changes(self, message: str = "Update DDL objects") -> bool:
        """Commit changes to git repository."""
        try:
            if not self.repo:
                logger.error("Git repository not initialized")
                return False
            
            # Add all files
            self.repo.git.add(A=True)
            
            # Check if there are changes to commit
            if self.repo.is_dirty() or self.repo.untracked_files:
                self.repo.index.commit(message)
                logger.info(f"Committed changes: {message}")
                return True
            else:
                logger.info("No changes to commit")
                return True
                
        except Exception as e:
            logger.error(f"Failed to commit changes: {e}")
            return False
    
    def get_file_content(self, object_type: str, object_name: str) -> Optional[str]:
        """Get content of a DDL file."""
        try:
            file_path = self.repo_path / object_type / f"{object_name}.sql"
            if file_path.exists():
                return file_path.read_text(encoding='utf-8')
            return None
        except Exception as e:
            logger.error(f"Failed to read file {object_type}/{object_name}: {e}")
            return None
    
    def list_objects(self, object_type: str) -> List[str]:
        """List all objects of a specific type in the repository."""
        try:
            object_dir = self.repo_path / object_type
            if not object_dir.exists():
                return []
            
            return [f.stem for f in object_dir.glob("*.sql")]
        except Exception as e:
            logger.error(f"Failed to list {object_type} objects: {e}")
            return []
    
    def get_commit_history(self, limit: int = 10) -> List[Dict]:
        """Get commit history."""
        try:
            if not self.repo:
                return []
            
            commits = []
            for commit in self.repo.iter_commits(max_count=limit):
                commits.append({
                    'hash': commit.hexsha[:8],
                    'message': commit.message.strip(),
                    'author': str(commit.author),
                    'date': commit.committed_datetime.isoformat()
                })
            return commits
        except Exception as e:
            logger.error(f"Failed to get commit history: {e}")
            return []
